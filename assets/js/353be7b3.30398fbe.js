"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[442],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=i,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||o;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6772:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],l={id:"runner",title:"Runner"},s="Runner and Our First Algorithm",p={unversionedId:"basics/runner",id:"basics/runner",title:"Runner",description:"In this chapter we are going to create our own Genetic Algorithm.",source:"@site/../cilib-docs/target/mdoc/basics/runner.md",sourceDirName:"basics",slug:"/basics/runner",permalink:"/docs/basics/runner",draft:!1,tags:[],version:"current",frontMatter:{id:"runner",title:"Runner"}},d={},u=[{value:"What is Runner?",id:"what-is-runner",level:2},{value:"Iteration",id:"iteration",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"Creating a GA",id:"creating-a-ga",level:2},{value:"Imports",id:"imports",level:3},{value:"The Problem Environment",id:"the-problem-environment",level:3},{value:"The GA Algorithm",id:"the-ga-algorithm",level:3},{value:"Selection Method",id:"selection-method",level:3},{value:"Selection Method",id:"selection-method-1",level:3},{value:"Crossover Method",id:"crossover-method",level:3},{value:"Mutation Method",id:"mutation-method",level:3},{value:"My GA",id:"my-ga",level:3},{value:"Creating a Collection",id:"creating-a-collection",level:3},{value:"Creating an Iterator",id:"creating-an-iterator",level:3},{value:"Running our GA",id:"running-our-ga",level:3},{value:"Summary",id:"summary",level:2}],m={toc:u};function c(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"runner-and-our-first-algorithm"},"Runner and Our First Algorithm"),(0,o.kt)("p",null,"In this chapter we are going to create our own Genetic Algorithm.\nThere are a few things we are going to have to discuss first before we jump into the creating a GA."),(0,o.kt)("p",null,'CILib offers a data type that we may use to run our algorithms.\nI say "may" because, if so choose, you create your own way of running the algorithms.\nThis data type is called ',(0,o.kt)("inlineCode",{parentName:"p"},"Runner"),".\n",(0,o.kt)("inlineCode",{parentName:"p"},"Runner")," isn't a part of the cilib-core, but is included in this part of the book because it is needed to demonstrate everything we have learnt.\nIn order to include ",(0,o.kt)("inlineCode",{parentName:"p"},"Runner")," to your project you need to add ",(0,o.kt)("inlineCode",{parentName:"p"},"cilib-exec")," as a dependency in your ",(0,o.kt)("inlineCode",{parentName:"p"},"build.sbt"),"."),(0,o.kt)("p",null,"And since we are creating a GA we should also include ",(0,o.kt)("inlineCode",{parentName:"p"},"cilib-ga"),".\nThe reason we are creating a GA rather than, let's say,\na PSO is that the ga package uses types we have seen before where as a PSO uses types exclusive to the PSO package (W=we will explore these later)."),(0,o.kt)("p",null,"Your library dependencies should look very similar to the following..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n    "net.cilib" %% "cilib-core" % "2.0.0+124-2cd7fc13-SNAPSHOT",\n    "net.cilib" %% "cilib-ga" % "2.0.0+124-2cd7fc13-SNAPSHOT",\n    "net.cilib" %% "cilib-exec" % "2.0.0+124-2cd7fc13-SNAPSHOT"\n)\n')),(0,o.kt)("p",null,"Once you have refreshed your project we can start looking at what ",(0,o.kt)("inlineCode",{parentName:"p"},"Runner")," is."),(0,o.kt)("h2",{id:"what-is-runner"},"What is Runner?"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Runner")," is an object within CILib that allows us to control the execution of our algorithm.\nIt provides us with methods that allow us to specify the:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Number of iterations the algorithm should run for."),(0,o.kt)("li",{parentName:"ul"},"The algorithm."),(0,o.kt)("li",{parentName:"ul"},"The entities in the search space search space.")),(0,o.kt)("p",null,"Pretty cool, hey?\nThese are the discussed methods."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"repeat[F[_],A,B](n: Int, alg: Kleisli[Step[A,*],F[B],F[B]], collection: RVar[F[B]]): Step[A,F[B]]\n\nrepeatS[F[_],A,S,B](n: Int, alg: Kleisli[StepS[A,S,*],F[B],F[B]], collection: RVar[F[B]]): StepS[A,S,F[B]]\n")),(0,o.kt)("p",null,'"Woah, that looks intimidating".\nSure, it definitely can appear that way so let\'s try to clarify it a bit.\nThe difference between the algorithms is simply that the one is dealing with ',(0,o.kt)("inlineCode",{parentName:"p"},"Step")," and the other ",(0,o.kt)("inlineCode",{parentName:"p"},"StepS"),".\nSo you would choose which repeat method based on the type you used in your algorithm.\nAs for the parameters, ",(0,o.kt)("inlineCode",{parentName:"p"},"n: Int")," is the number of iterations the algorithm should run for.\nAnd ",(0,o.kt)("inlineCode",{parentName:"p"},"collection: RVar[F[B]]")," are our ",(0,o.kt)("em",{parentName:"p"},"entities")," in our search space.\nNow the second parameter is something we haven't come across yet.\nAll it is saying that we need an iteration type based on the algorithm."),(0,o.kt)("h3",{id:"iteration"},"Iteration"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Iteration")," is an object defined within ",(0,o.kt)("inlineCode",{parentName:"p"},"cilib-core")," that will create an ",(0,o.kt)("em",{parentName:"p"},"iterator")," of our algorithm.\nAn ",(0,o.kt)("em",{parentName:"p"},"iterator")," simply means are we running our algorithm synchronously or Asynchronously."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"sync_[M[_]:Applicative,A,B](f: NonEmptyList[A] => A => M[B]): Kleisli[M,NonEmptyList[A],NonEmptyList[B]]\n\nasync_[M[_]: Monad,A](f: NonEmptyList[A] => A => M[A]): Kleisli[M,NonEmptyList[A],NonEmptyList[A]\n")),(0,o.kt)("p",null,"These methods are very ",(0,o.kt)("em",{parentName:"p"},"raw")," and generic.\nThey are made public so that if you ever wanted to perhaps make your own iterator you could make use them if you desired so.\nThe following methods use the ",(0,o.kt)("em",{parentName:"p"},"raw")," and generic methods to create something we are a bit more familiar with."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def sync[A,B,C](f: NonEmptyList[B] => B => Step[A,C]) = sync_[Step[A,*],B,C](f)\n\ndef syncS[A,S,B,C](f: NonEmptyList[B] => B => StepS[A,S,C]) = sync_[StepS[A,S,*], B,C](f)\n\ndef async[A,B](f: NonEmptyList[B] => B => Step[A,B]) = async_[Step[A,*], B](f)\n\ndef asyncS[A,S,B](f: NonEmptyList[B] => B => StepS[A,S,B]) = async_[StepS[A,S,*], B](f)\n")),(0,o.kt)("p",null,"As we saw with runner we are given methods to handle both ",(0,o.kt)("inlineCode",{parentName:"p"},"Step")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"StepS")," based algorithms."),(0,o.kt)("h3",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"This may be a lot to take in.\nIf so don't worry as we are now going to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"GA")," from start to finish!"),(0,o.kt)("h2",{id:"creating-a-ga"},"Creating a GA"),(0,o.kt)("p",null,"Isn't this exciting!"),(0,o.kt)("p",null,"All our work over the past chapters is coming together!"),(0,o.kt)("p",null,"It should be noted that the only thing we will be using from\n",(0,o.kt)("inlineCode",{parentName:"p"},"cilib-ga")," is the type ",(0,o.kt)("inlineCode",{parentName:"p"},"Individual"),", which, as we discussed before, is\nan ",(0,o.kt)("inlineCode",{parentName:"p"},"Enity")," with a state of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit")," since GA's do not need a state."),(0,o.kt)("h3",{id:"imports"},"Imports"),(0,o.kt)("p",null,"We will be using the following ",(0,o.kt)("inlineCode",{parentName:"p"},"imports")," for our GA."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala",metastring:":silent",":silent":!0},"import cilib._\nimport cilib.ga._\nimport eu.timepit.refined.auto._\n")),(0,o.kt)("h3",{id:"the-problem-environment"},"The Problem Environment"),(0,o.kt)("p",null,"For our problem we are going to attempt to find the greatest area\nproduced by a 2 dimensional rectangle. The sides can range from 0.1\nto 12."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val bounds = Interval(0.1, 12.0)^2\n\nval env = Environment(\n    cmp = Comparison.dominance(Max),\n    eval =  Eval.unconstrained[NonEmptyList,Double](pos => Feasible(pos.foldLeft1_ * _))).eval\n)\n")),(0,o.kt)("h3",{id:"the-ga-algorithm"},"The GA Algorithm"),(0,o.kt)("p",null,"The GA algorithm is the same as the implementation within ",(0,o.kt)("inlineCode",{parentName:"p"},"cilib-ga"),"."),(0,o.kt)("p",null,"The reason we are intentionally defining it as opposed to importing it\nis so that we can see the inner workings and learn from it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def ga[S](\n             p_c: Double,\n             parentSelection: NonEmptyList[Individual[S]] => RVar[List[Individual[S]]],\n             crossover: List[Individual[S]] => RVar[List[Individual[S]]],\n             mutation: List[Individual[S]] => RVar[List[Individual[S]]]\n         ): NonEmptyList[Individual[S]] => Individual[S] => Step[Double,List[Individual[S]]] =\n    collection => x => for {\n        parents   <- Step.pointR(parentSelection(collection))\n        r         <- Step.pointR(Dist.stdUniform.map(_ < p_c))\n        crossed   <- if (r) Step.pointR[Double,List[Individual[S]]](crossover(parents))\n        else Step.point[Double,List[Individual[S]]](parents)\n        mutated   <- Step.pointR[Double,List[Individual[S]]](mutation(crossed))\n        evaluated <- mutated.traverseU(x => Step.eval((v: Position[Double]) => v)(x))\n    } yield evaluated\n")),(0,o.kt)("p",null,"Wow. There is a lot going on here.\nLet's break it down.\nFirst the parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"p_c //is our crossover rate\nparentSelection //is the function we will use to select the parents\ncrossover //is the function that we will use to produce off spring\nmutation //is the function we will use to mutate the offspring\n")),(0,o.kt)("p",null,"All right. Not too bad. By being able to pass functions to a generic\nGA method allows us to build a GA specific to our needs. It should\nalso be noted that all the passable functions yield the same data\ntype. Now before we move to the actual implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ga"),"\nmethod, I would like to remind you that for comprehensions are\nessentially chained ",(0,o.kt)("inlineCode",{parentName:"p"},"flatMaps"),". This allows us to chain steps\ntogether. So we know that this method will return a function of type"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList[Individual[S]] => Individual[S] => Step[Double,List[Individual[S]]]")),(0,o.kt)("p",null,"Which in simply means, that we are going to get a function that return\na ",(0,o.kt)("inlineCode",{parentName:"p"},"Step")," representing a series of computations applied to every\n",(0,o.kt)("inlineCode",{parentName:"p"},"Individual")," with a collection of ",(0,o.kt)("inlineCode",{parentName:"p"},"Individuals"),'. Okay, so now we know\nwhat we are returning but let\'s see how we get to that by looking at\nthe "series of computations".'),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"parents <- Step.pointR(parentSelection(collection))")),(0,o.kt)("p",null,"Here we are selecting our parents from the collection using the\nparentSelection function that was passed as a parameter. Lastly, it\nwill be wrapped in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Step"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"r <- Step.pointR(Dist.stdUniform.map(_ < p_c))")),(0,o.kt)("p",null,"Here we are assigning a ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean")," wrapped in an ",(0,o.kt)("inlineCode",{parentName:"p"},"Step"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"crossed <-\n  if (r) Step.pointR[Double,List[Individual[S]]](crossover(parents))\n  else Step.point[Double,List[Individual[S]]](parents)\n")),(0,o.kt)("p",null,"If r is ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," we will produce crossovers based on the ",(0,o.kt)("inlineCode",{parentName:"p"},"parents")," using\nthe crossover function parameter, else we are going to just leave the\nparents as is. How frequently the crossover occurs depends on your\n",(0,o.kt)("inlineCode",{parentName:"p"},"p_c"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"mutated <- Step.pointR[Double,List[Individual[S]]](mutation(crossed))")),(0,o.kt)("p",null,"Nothing too complex here. We are simply mutating our ",(0,o.kt)("inlineCode",{parentName:"p"},"crossed"),"\nindividuals using the mutation function parameter. Also note that\n",(0,o.kt)("inlineCode",{parentName:"p"},"mutated")," will have a data type very similar tto our return type."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"evaluated <- mutated.traverseU(x => Step.eval((v: Position[Double]) => v)(x))")),(0,o.kt)("p",null,"Lastly, we are taking every ",(0,o.kt)("inlineCode",{parentName:"p"},"Individual")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"mutated")," and wrapping\neach one in an evaluation ",(0,o.kt)("inlineCode",{parentName:"p"},"Step"),". Remember that this is just a step\nrepresenting evaluation, not actually evaluating the ",(0,o.kt)("inlineCode",{parentName:"p"},"Individuals"),"\nright now."),(0,o.kt)("p",null,"Let's get to creating the functions we will be passing to our ga method."),(0,o.kt)("h3",{id:"selection-method"},"Selection Method"),(0,o.kt)("p",null,"For our selection method we will be creating a random selection\nmethod. We know that it needs to have the type\n",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList[Individual[S]] => RVar[List[Individual[S]]]"),". To make\nthis even easier to read we can include a custom type, ",(0,o.kt)("inlineCode",{parentName:"p"},"type Ind =\nIndividual[Unit]"),", making it ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList[Ind] =>\nRVar[List[Individual[S]]]"),". Create a function with the name\n",(0,o.kt)("inlineCode",{parentName:"p"},"randomSelection")," that will randomly select two ",(0,o.kt)("inlineCode",{parentName:"p"},"Inds")," from an non\nempty list."),(0,o.kt)("div",{class:"solution"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala",metastring:":silent",":silent":!0},"type Ind = Individual[Unit]\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val randomSelection: NonEmptyList[Ind] => RVar[List[Ind]] =\n    (l: NonEmptyList[Ind]) => RVar.sample(2, l).map(_.getOrElse(List.empty[Ind]))\n"))),(0,o.kt)("h3",{id:"selection-method-1"},"Selection Method"),(0,o.kt)("p",null,"For our selection method we will be creating a random selection\nmethod. We know that it needs to have the type\n",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList[Individual[S]] => RVar[List[Individual[S]]]"),". To make\nthis even easier to read we can include a custom type, ",(0,o.kt)("inlineCode",{parentName:"p"},"type Ind =\nIndividual[Unit]"),", making it ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList[Ind] =>\nRVar[List[Individual[S]]]"),". Create a function with the name\n",(0,o.kt)("inlineCode",{parentName:"p"},"randomSelection")," that will randomly select two ",(0,o.kt)("inlineCode",{parentName:"p"},"Inds")," from an non\nempty list."),(0,o.kt)("div",{class:"solution"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val randomSelection: NonEmptyList[Ind] => RVar[List[Ind]] =\n    (l: NonEmptyList[Ind]) => RVar.sample(2, l).map(_.getOrElse(List.empty[Ind]))\n"))),(0,o.kt)("h3",{id:"crossover-method"},"Crossover Method"),(0,o.kt)("p",null,"We will be creating a one point crossover method to be used in our GA.\nIt will need to have the type ",(0,o.kt)("inlineCode",{parentName:"p"},"List[Individual[S]] =>\nRVar[List[Individual[S]]]")," and let's call it ",(0,o.kt)("inlineCode",{parentName:"p"},"onePoint"),". There should\nbe two ",(0,o.kt)("inlineCode",{parentName:"p"},"Individuals"),", parents, in the list that will be used to create\ntwo new ",(0,o.kt)("inlineCode",{parentName:"p"},"Individuals")," from a one point cross over. Else we should\noutput an error."),(0,o.kt)("div",{class:"solution"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def onePoint(xs: List[Ind]): RVar[List[Ind]] =\n    xs match {\n        case a :: b :: _ =>\n            val point: RVar[Int] = Dist.uniformInt(Interval(0, a.pos.pos.size - 1))\n            point.map(p => List(\n                a.pos.take(p) ++ b.pos.drop(p),\n                b.pos.take(p) ++ a.pos.drop(p)\n            ).traverse(_.toNel.map(x => Entity((), Point(x, a.pos.boundary)))).getOrElse(List.empty[Ind]))\n        case _ => sys.error("Incorrect number of parents")\n    }\n'))),(0,o.kt)("h3",{id:"mutation-method"},"Mutation Method"),(0,o.kt)("p",null,"Our mutation method will be relatively simply. For every ",(0,o.kt)("inlineCode",{parentName:"p"},"Individual"),"\nwe want to mutate its position where each point in the position is\nmutated based on a ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean"),". If It is true, mutate the point by\nmultiplying by a random number from a gaussian distribution. Else\nleave it as it is. This deciding ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean")," is determined the same way\nr is in our ",(0,o.kt)("inlineCode",{parentName:"p"},"ga")," method. Except, that is compared with a double\nparameter, ",(0,o.kt)("inlineCode",{parentName:"p"},"p_m"),", representing the mutation rate. So you might need\ngroups of parameters. Call this method ",(0,o.kt)("inlineCode",{parentName:"p"},"mutation")," and be aware of\nit's return type. Also some helpful hints are to think about using\n",(0,o.kt)("inlineCode",{parentName:"p"},"Lenses")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"ModifyF")," function, as well as ",(0,o.kt)("inlineCode",{parentName:"p"},"traverse")," for\nsequencing through points ot a list."),(0,o.kt)("div",{class:"solution"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def mutation(p_m: Double)(xs: List[Ind]): RVar[List[Ind]] =\n    xs.traverse(x => {\n        Lenses._position.modifyF((p: Position[Double]) => p.traverse(z => for {\n            za <- Dist.stdUniform.map(_ < p_m)\n            zb <- if (za) Dist.stdNormal.flatMap(Dist.gaussian(0,_)).map(_ * z) else RVar.point(z)\n        } yield zb\n        ))(x)\n    })\n"))),(0,o.kt)("h3",{id:"my-ga"},"My GA"),(0,o.kt)("p",null,"Now that we have defined all those methods we should be able to\nconstruct our GA with the following line of code:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"val myGA = ga(0.7, randomSelection, onePoint, mutation(0.2))")),(0,o.kt)("p",null,"Great! Remember that what we have here is still just a function. One\nthat takes a collection of ",(0,o.kt)("inlineCode",{parentName:"p"},"Individuals")," and returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"Step"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList[Ind] => Ind => Step[Double,List[Ind]]")),(0,o.kt)("h3",{id:"creating-a-collection"},"Creating a Collection"),(0,o.kt)("p",null,"We have the ",(0,o.kt)("inlineCode",{parentName:"p"},"myGA")," function, but not the collection. So let's go ahead and\ncreate that. Keep in mind that we are dealing with ",(0,o.kt)("inlineCode",{parentName:"p"},"Individuals")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val swarm = Position.createCollection[Ind](x => Entity((), x))(bounds, 20)\n")),(0,o.kt)("h3",{id:"creating-an-iterator"},"Creating an Iterator"),(0,o.kt)("p",null,"Here is where things get a little more interesting. Remember the\n",(0,o.kt)("inlineCode",{parentName:"p"},"Iteration")," section earlier in this chapter? Here is where we dive\ninto that. I'll first present the code and then we can go over it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val iterator =\n    Iteration.sync(myGA).map(_.suml)\n      .flatMapK(r => Step.withCompare(o =>\n        r.sortWith((x,y) => Comparison.fittest(x.pos,y.pos).apply(o)))\n          .map(_.take(20).toNel.getOrElse(sys.error("error"))))\n')),(0,o.kt)("p",null,"This code creates a synchronous iterator based on our ga that at each\ngeneration select the best 20 based on our comparison dominance.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Iteration.sync(myGA).map(_.suml)")," allows us to work with a\n",(0,o.kt)("inlineCode",{parentName:"p"},"List[Ind]"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"r")," is an ",(0,o.kt)("inlineCode",{parentName:"p"},"Ind")," which becomes a ",(0,o.kt)("inlineCode",{parentName:"p"},"Step")," with a\ncomparison."),(0,o.kt)("h3",{id:"running-our-ga"},"Running our GA"),(0,o.kt)("p",null,"Lastly, running our program requires a ",(0,o.kt)("inlineCode",{parentName:"p"},"Runner"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"println(Runner.repeat(1000, iterator, swarm).run(env).eval(RNG.init(12L)).toString)")),(0,o.kt)("p",null,"This line of code will produce the results of our ga after 1000\niterations as a string."),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"Well done!\nWe have successfully implemented a genetic algorithm using CILib.\nWhats great is that the code is easy to reuse.\nI encourage you to modify the code and really make it your own.\nIf, for whatever reason, you got stuck during the example here is the ","[link][ga-example-link]"," to where the example was based off.\nAnd for more example of CILib implementations you can view the example package ","[here][example-package]","."))}c.isMDXComponent=!0}}]);